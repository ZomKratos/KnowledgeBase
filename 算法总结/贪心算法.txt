贪心算法定义：从局部最优解推导出全局最优解。
例子：取10次钱，求取得最多钱的总额。
框架套路：无，分散很广
思考过程：
1.什么时候局部最优？
2.能不能推断在局部最优的情况下全局最优？
经典例题：
1.跳跃游戏：给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。问能否到达终点。
重点是在遍历时维护能够跳跃到的最远位置range

2.跳跃游戏2：在跳跃游戏的基础上问最少跳跃次数。
重点是在遍历时维护一个最远位置nextRange而不立马更新为range，若下标遍历到range，给跳跃次数加一再将nextRange赋值给range

3.加油站：给出加油、耗油两个数组，从哪个节点出发可以绕场一圈。
重点是所有站点的油量净增长之和为正则可以绕一周，为负则不行。在遍历中维护一个局部净增长之和，当和为负数时，开始节点设置为i+1，将和清零。
https://www.bilibili.com/video/BV1jA411r7WX/?spm_id_from=333.788&vd_source=520507ee68d0275dd5a85a19198e4f11

4.无重叠区间：给出几个区间，问要至少去掉几个区间才能让区间之间无重复区域。
重点：按起点排序。遍历过程中每次都只和上一次循环的区间对比，如果当前区间的起点小于上一个区间的终点，则把当前区间的终点设置为(当前区间的终点和上一个区间终点)的最小值，以模拟(去掉有更远的终点的区间)这一过程，方便下一次循环来对比本次的区间，并且count++。

5.划分字母区间：给出一个字符串，要求划分出最多子串，每个字母最多出现在一个子串中，返回每段的长度列表。
重点：先遍历一遍字符串，获取记录每个字符最晚出现的位置的字典。再遍历字符串，在每次循环中维护'结束当前段至少需要到达的位置range'(range = max(range, dic[s[i]]))，然后检查当前序号是否是range，如果是则把前一段长度加入列表，range+1。

6.合并区间：给出一个交错数组表示若干个区间，合并所有重叠的区间并返回区间数组。
重点：和无重叠区间思路差不多，先按起点排序。遍历中每次循环和上一次的区间对比，如果重叠，就融合上一个区间和这个区间，不把他放入结果队列中，等待下一次循环是否还融合；如果不重叠，就把上一个区间放入结果队列中。最后要记得做末尾检测把最后一个区间放入队列中。

7.单调递增的数组串：当相邻位置x和x+1满足x<=x+1则该整数是单调递增的。给一个整数n，求小于或等于n的最大单调递增数字。
重点：要从后向前遍历，维护一个下标index，表示从index位开始的值都要设置为'9'，index在x+1位大于x为的时候记录x+1。结束后再开启一个循环，把所有index后的值设置为‘9’。

总结：贪心算法就是复杂一点正常算法题，关键在于能否把局部最优推断出全局最优。如果能看出规律的话，通常一个循环就写完了。
关键字：区间，加油站，跳跃游戏。



