--------------------------------------------------------------------------一、基础语法--------------------------------------------------------------------------
C++类对象创建方式：
class Son{
}			//类的声明
Son s1;			//类的定义(调用了构造函数)
Son* s2;			//指针声明(并未赋值和调用构造函数
Father f1 = Son();		//将子类实例赋值给父类对象
int* a = new int(1); cout << *a;	//解引用

声明与定义的区别：是否分配了内存空间
    声明的典型形式：
        extern int x;（变量声明）
        void func();（函数声明）
        class Foo;（类声明）
    定义的典型形式：
        int x;
        int x = 5;
        void func() { ... }
        class Foo { int x; };
        Foo fo;
即除了三种声明形式，其他语法都是定义，都分配了内存空间。
注意：
    1.定义(分配空间)不等于赋值，全局变量会自动赋值为0，而局部变量或类成员不会，要自己赋值。
    2.类对象在定义时会自动调用构造函数，使类方法可以调用，但是类成员也需要手动初始化(一般在构造函数中)，不然也无法使用。

分辨常量指针和指针常量：从左向右读。
int a = 1;
int* const b = &a;
int const *c = &a;
b是一个const pointer，指针常量，这个指针的指向不能变(即指针存的地址不能变)。
c是一个pointer to const，常量指针，指向常量的指针(指针常量，最好不要用这个名字，容易混淆)，这个指针指向的对象的值不能变。
理解的时候从右向左理解，* const意思是const的pointer，const *的意思是pointer to const。
注意：只有常量指针(指向常量的指针)才能指向一个常量
例如：
const int a = 1;
int const *b = &a;//正确
int * c = &a;//错误

指针的值是一个地址，而不是对象。
所以赋值的时候要用：
int a = 10;
int* b = &a;

delete在什么情况使用：
1.在一个方法中如果用new创建了对象，那么在方法结束前要把它手动delete掉，不然就会内存泄漏。
2.如果一个指针本来指向一个对象，那么当指针指向另一个新对象的时候要先把旧的对象delete掉。
3.在一个方法中如果用new创建了对象，那么除了在方法结束前要把它手动delete掉之外，还要看这个对象内部是否还有指针，如果对象内部还有个动态数组，那么要在类的析构函数中释放这个动态数组。
注意：delete数组要用 delete[] arr。

宏定义只做文本替换而不做类型检查，容易导致运算优先级的问题和类型错误的问题：
// 内联函数
inline int add(int x) {
    return x + 1;
}
// 预处理宏
#define SQUARE(x) x + 1
int main(){
    int b = 2;
    int result_inline = Square(b) * Square(b); 
    int result_macro = SQUARE(b) * SQUARE(b);   // 运算优先级导致错误
}
函数的调用过程：跳转到函数体中-把函数上下文(一个寄存器)入栈-执行函数体-把函数上下文(同一个寄存器)出栈-返回调用点。
内联函数的优化：把函数嵌入到调用它的地方，不再跳转函数体，不再执行入栈出栈操作。

用int arr[3] = {1,2,3}的方式创建的是静态数组，长度参数只能传常数，而常数必须在声明时赋值，所以输入的值无法赋值给常数，也就不能通过输入值来创建长度为n的静态数组。

引用相当于给一个变量取别名。本质是一个指针常量，被编译器特殊处理，可以直接给这个指针赋值而不是赋地址。
int a = 10;
int& b = a;  //编译器处理为int * const b = &a;
修改引用的值会直接去修改这个指针指向的对象的值，而不是指针的指向
int c = 20;
b = c; //编译器处理为*b = c;
例如：
	int a = 1;
	int b = 2;
	int& c = a;
	c = b;
	cout << a;	//输出2
c = b并不会修改引用c的指向(所以不会报错)，而是被翻译为了*c = b;也就是直接把a的值改变为b了。

普通指针和引用无法被常量赋值，只有常量指针才能指向常量。

函数指针：return_type (*pointer_name)(argument_type1, argument_type2, ...);
//初始化：
void (*fptr)(int， int) = &Func; 
或
void (*fptr)(int， int) = Func; 
或
void (*fptr)(int， int)；
fptr = Func;
//调用
(*fptr)(1);	//显示调用
fptr(1);	//隐式调用
注意：*pointer_name周围的括号是一定不能少的，不然会和函数声明混淆。

当想让一个函数作为方法的参数传入时，可以用函数名也可以用函数指针，两者完全等效(C++中允许函数作为一个参数传入)
void Func2(void func(int i)) {
    cout<< "函数"<< endl;
}
void Func3(void (*fptr)(int i)) {
    cout<< "函数指针"<< endl;
}
甚至可以给Func2传一个函数指针，给Func3传一个函数名，都可以运行。
这是因为单独的函数(非调用)会被解释为函数指针，这也是为什么cout << &Func << endl << Func << endl;输出的值相同。
指针作为函数的参数时，形参是一个临时创建的局部指针，指向实参指针。

函数指针使用样例：
void Func() {
    std::cout << "Func!";
}
void Func2(void FuncPara()) {}		//即使不适用函数指针，函数也可以这样作为参数传入
void Func3(void (*FuncPara)()) {}	//与Func2等效
int main()
{
    void (*FuncPtr)();			//定义函数指针
    FuncPtr = &Func;			//赋值
    (*FuncPtr)();			//调用
}


void* 是可以指向任意类型的指针。其他类型指针可以直接赋值给void*类型指针，而void*类型的指针想赋值给其他类型的指针需要强制转换。
void*类型指针只有强制转化为一个具体类型指针后才能用*访问其内存空间。

32位操作系统指针占4字节，64位操作系统指针占8字节

空类对象占1字节的原因：让空类对象有一个容身之地。
int main() {
    Empty e;  // Empty类中什么都没有，但如果是0字节那么栈后续的插入对象就乱套了，于是e占1字节
}
--------------------------------------------------------------------------二、类与对象--------------------------------------------------------------------------
C++中类可以创建在栈上或创建在堆上，唯一的区别是 是否使用new！
Student stu = Student();		//这是标准写法！创建在栈上。
Student stu;			//缩略写法，在定义时会自动调用构造函数
Student stu();			//坑爹写法，仅仅声明了一个返回值为Student的方法，而不是定义
Student stu(c, 15, 92.5f);		//有点坑爹的写法，虽然是正常调用了构造函数
Student* pstu = new Student();		//创建在堆上
Student* pstu = new Student(c, 15, 92.5f);	//创建在堆上
注意：
创建在堆上的类对象new的返回值是一个指针，必须要用指针来接收这个值。同时这意味着存在堆上的类要用指针才能调用，指针调用一个类的的成员要用->。
创建在栈上的类对象的赋值操作是值拷贝，改变其中一个类的值另一个类不会改变。

相比C#，C++可以把类方法的[实现]写在类外，只需要在前面加上作用域，但是记得要先在类中声明：
class Student {
public:
 Student();
};
Student::Student() {
    ...
}
而C#不支持方法的声明和实现分离。

拷贝构造函数是一种特殊的构造函数，与一般构造函数的唯一区别就是拷贝构造函数传的参数是(const Student& stu)，即一个被const修饰的该类实例的引用。
至于为什么要加const，一是因为传来的参数是用来赋值的，防止修改原始参数，二是因为使用const的话可以接收const参数和非const的实参，而不用的话实参就只能传非const实参(因为作为一个指针，只能指向非常量)。
至于为什么是引用，因为如果是对象，那么形参复制实参时会递归地调用拷贝构造函数(而创建引用可以看做创建一个指针，指向一个变量并不会调用拷贝构造函数构造一个新对象)。

拷贝构造函数写法：
	Person(const Person& person) {
		cout << "拷贝构造！";
		...
	}
=运算符重载写法：
	Person& operator=(const Person& person) {
		cout << "赋值运算符重载！";
		...
	}

拷贝构造函数在什么情况下会被调用？
    1.使用已有的对象创建新对象时：
        Student* s1 = new Student("aaa");
        Student* s2 = new Student(*s1);		//拷贝构造函数
    或
        Student s1("aaa");
        Student s2(s1);
        Student s3 = s1;			//拷贝构造函数
        s3 = s2;				//赋值操作符
注意：可以自定义拷贝构造函数以实现深拷贝。
    2.在函数参数值传递时：
        void Func(Student s) {
    	...
        }
        int main(){
            Student* s1 = new Student("aaa");
            Func(*s1);
        }
注意：默认拷贝构造函数和赋值操作都是浅拷贝。
注意：C#已不再提供默认拷贝构造函数
注意：Student* s = &s1;不是拷贝，而是指针的赋值。

类实例被创建时会带有默认的拷贝构造函数，这个默认的拷贝构造函数会执行浅拷贝，也就是把栈中成员的值进行一次拷贝。
在某些情况下我们希望深拷贝，这时需要自定义拷贝构造函数。
什么时候需要自定义拷贝构造函数？
    1.类中有指针类型成员（动态分配内存）。
    2.类中有特殊资源管理对象（如文件、数据库连接）。

自定义拷贝构造函数例子：当类中存在指针时
    MyClass(const MyClass& other) {
        num = new int(*other.num)
    }

this是一个指针，指向被调用的成员函数所属的对象。

类的初始化方式之一 —— 初始化列表：
Student::Student(int id, int age):id(id),m_age(22),name("chen") {
    ...
}

使用初始化列表的情况：
    1.类成员有常量
        注意：非必须，也可在定义时直接赋值。但是若想要通过外部参数赋值，就必须用初始化列表而非构造函数。
        常量有全局常量、类成员常量、局部常量三种。除了类成员常量，其他两种都必须要在定义的时候初始化。而类成员常量除了可以在定义时初始化也可以用初始化列表进行初始化，但是不能在构造函数中赋值。初始化和赋值是不同的，构造函数中是在赋值而不是在初始化。
    2.类成员有引用(引用即特殊的指针常量)
        注意：非必须，也可在定义时直接赋值。但是若想要通过外部参数赋值，就必须用初始化列表而非构造函数。
        引用成员需要在定义的时候初始化或者在初始化列表中初始化，而不能在构造函数中初始化。
    3*.在子类的构造函数中想要调用父类特定的有参构造函数而不是默认构造函数
        注意：这个是必须的，不然只会调用父类的默认构造函数，而不是有参构造函数。
        使用方式：Son():Father(1){}

初始化列表使用样例：
class MyClass
{
private:
    const int year;
    const int month;
    const int day;
public:
    MyClass() :year(1),month(2),day(3){}		
};
在C#中使用base而不用父类名。C#中常量定义后必须被赋初始值。

当父类的方法不是虚方法时，子类中的同名方法不会干扰父类中的方法。
class Base{
public:
	 void printError(){  //使用virtual关键字声明函数，将其变为虚函数，即可使用多态
	 cout << "基类方法!" << endl;
	 };
};
//派生类
class Derived : public Base{
public:
	 void printError(){
		cout << "派生类方法!" << endl;
	}
};
void test()
{	
	Base *ex = new Derived(); //静态联编导致子类对象调用基类方法，而不是子类方法
	ex->printError(); //输出基类方法！
}
而当父类方法前添加virtual关键字的话，子类中的同名方法会重写父类的方法，就能使用多态。

当把一个派生类实例赋给一个基类对象(而非指针)时，会发生对象切片(object slicing)，只保留父类的属性和方法，即使使用了virtual关键字也会导致调用的方法变为基类方法。
void test()
{	
	Base e = Derived(); //对象切片导致子类对象调用基类方法，而不是子类方法
	ex.printError(); //输出基类方法！
}

-----------------------------------多态-----------------------------------
多态分为静态多态和动态多态。
静态多态也叫编译多态，由函数重载实现。动态多态也叫运行多态，由函数重写实现。
多态实现的条件：
1.父类方法有virtual关键字，子类中有同名方法去重写(C++中不需要override关键字)
2.用父类的指针(或引用)指向子类对象，调用子类重写的虚函数

🎯 一句话总结：多态允许使用基类指针或引用来调用子类的重写方法,从而使得同一接口可以表现不同的行为。
你可以只用子类指针没问题，但只适合你“明确知道类型”的场合。
而多态是为了解耦，让程序“处理未知类型的子类”时依然能工作。

当不使用多态时，子类对象的创建的顺序是：父类构造函数-子类构造函数-子类析构函数-父类析构函数。
当使用多态的时候，需要把父类指针的析构函数设置为虚函数，这样的话在delete父类指针时会先调用子类的析构函数，再调用父类的析构函数。不然只会调用父类的析构函数。

构造函数可以是虚函数吗？：不能。
因为虚函数实现所依赖的虚函数表指针要靠构造函数来创建，如果构造函数还没运行，就没有虚函数表指针，也就无法调用虚函数。
静态函数可以是虚函数吗？：不能。
因为静态函数在编译时确定，虚函数在运行时才能确定。
------------------------------------------------------------------------

子类调用父类的方法(即使子类重写了父类方法也可以调用)：
1.在类方法中：
    void Func() {
        Father::Func();
        cout << "son";
    }
2.用子类实例调用：
    Son son = Son();
    son.Father::Func();
类比C#只能在类方法中使用base.Func()调用父类方法

编译器给类自动生成的四个函数：默认构造函数、拷贝构造函数、赋值函数、析构函数。(C#中应该只有默认构造函数)

结构体和类都可以选择实例化在堆上或在栈上，他们都可以继承、实现函数、实现多态，作用几乎相同。(C#中结构体是值类型，只能存在栈中，不支持继承，成员默认访问权限是private)
唯二的不同：
class成员的默认访问级别是private，struct成员的默认访问级别是public。
class继承的默认方式是private，struct继承的默认方式是public。
即：结构体是轻量级的类，设计的默认权限和默认继承权限都是public，在存储的数据不多，函数不复杂时可以使用结构体。

public继承：父类中各成员不变。(也是C#的继承方式)
protected继承：父类中public成员对于子类变成protected。
private继承：父类中public、protected成员对于子类变成private。

--------------------------------------------------------------------------三、内存管理--------------------------------------------------------------------------
C++存储区域5个：
内存区域	           	存储内容				管理方式			生命周期		特点
栈区 (Stack)	局部变量, 函数参数, 返回地址		编译器自动管理		函数调用/作用域	速度快, 空间有限, 可能栈溢出
堆区 (Heap)	动态分配的内存 (new, malloc)		程序员手动/智能指针管理	从分配到释放	速度慢, 空间大, 可能内存泄漏/碎片
全局/静态存储区	全局变量, 静态变量			编译器分配, OS 回收		整个程序运行期	生命周期长, 分为 Data 和 BSS 段
常量存储区	字符串字面量, 全局常量		编译器分配, OS 回收		整个程序运行期	只读, 共享
代码区 (Code Area)	编译后的可执行机器指令 (例如函数体)	编译器链接器生成, OS 加载	整个程序运行期	只读, 可执行, 可共享
详情可见：https://blog.csdn.net/weixin_40514381/article/details/146522313
注意：只有全局变量、静态变量放在全局/静态区，加上常量前缀后放在常量区。

结构体和类都可以选择实例化在堆上或在栈上，他们都可以继承、实现函数、实现多态，作用几乎相同。(C#中结构体是值类型，只能存在栈中，不支持继承，成员默认访问权限是private)
唯二的不同：
class成员的默认访问级别是private，struct成员的默认访问级别是public。
class继承的默认方式是private，struct继承的默认方式是public。









--------------------------------------------------------------------------四、STL标准模板库--------------------------------------------------------------------










--------------------------------------------------------------------------五、高级特性--------------------------------------------------------------------------
decltype关键字：是declaration type(声明类型)的缩写。可以通过括号中表达式的类型返回相应的数据类型。
如果括号中的表达式被第二层括号括起来，则返回一个该类型的引用(引用必须要赋初始值)。
int a = 1;
decltype(i) b = 2;
decltype(i)* aptr = new int(1);
decltype((i)) aref = new int(2);

范围for循环：类似foreach()，只能用于可以求长度的数据结构，例如vector、内置数组等，而用new创建的动态数组无法获取其长度信息，就不能用范围for循环遍历
for(auto i : arr){
    ...
}

C++也有lambda表达式，用来写匿名函数(C#中也是)：
语法如下：
[捕获列表](参数) -> 返回值类型 {
    // 函数体
}
例子：
auto sum = [](int a, int b)-> int {
    return a + b;
};
捕获列表传的是外部的变量，给变量前加&表示捕获引用。若列表中只有一个"="符号，表示按值捕获所有外部变量，若只有一个符号"&"表示按引用捕获所有外部变量。
int x = 42, y = 24;
auto lambda = [x, &y] {
    std::cout << x << ", " << y << std::endl;
};
捕获：用于将外部作用域的变量传递给 lambda 表达式。它控制 lambda 如何与外部变量交互。
参数：用于将数据传递给 lambda 表达式进行计算或处理，类似于普通函数的参数。









--------------------------------------------------------------------------编译与链接------------------------------------------------------------------------

