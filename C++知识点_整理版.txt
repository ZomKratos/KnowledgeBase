--------------------------------------------------------------------------一、基础语法--------------------------------------------------------------------------
3种面向对象特征，4种类自动提供的方法，5个内存存储区域，6个？，10种重要STL容器

很多官方头文件的类、方法都写在了std作用域下(iostream/vector/deque等)，所以在使用这些方法前要使用std::xxx。
在不自己定义自己的容器、算法的前提下可以直接使用using namespace std;来简化后续的调用。

C++类对象创建方式：
class Son{
}			//类的声明
Son s1;			//类的定义(调用了构造函数)
Son* s2;			//指针声明(并未赋值和调用构造函数
Father f1 = Son();		//将子类实例赋值给父类对象
int* a = new int(1); cout << *a;	//解引用

声明与定义的区别：是否分配了内存空间
    声明的典型形式：
        extern int x;（变量声明）
        void func();（函数声明）
        class Foo;（类声明）
        static int value;(作为类成员时只是声明，定义要在类外的.cpp中定义)
    定义的典型形式：
        int x;
        int x = 5;
        void func() { ... }
        class Foo { int x; };
        Foo fo;
即除了三种声明形式，其他语法都是定义，都分配了内存空间。
注意：
    1.定义(分配空间)不等于赋值，全局变量会自动赋值为0，而局部变量或类成员不会，要自己赋值。
    2.类对象在定义时会自动调用构造函数，使类方法可以调用，但是类成员也需要手动初始化(一般在构造函数中)，不然也无法使用。

数组相关：
    1.数组分为静态数组(栈上)和动态数组(堆上)，分别定义方式如下：
        int arr[100];		//只定义，未初始化，值为一个负数
        int arr[100] = { 1 };	//定义且初始化，第一个值为1，其余值被初始化为0
        int* arr = new int[5];	//只定义，未初始化，值为一个负数
        int* arr = new int[5]{ 1 };	//定义且初始化，其余值初始化为0

algorithm头文件中的重要方法(静态数组、动态数组、容器中都适用)：
    1、std::find：查找元素
            int arr[] = {5, 3, 8, 1, 2};
            auto it = std::find(arr, arr + 5, 3);  // 查找元素 3
            if (it != arr + 5) {
                std::cout << "Found!" << std::endl;  // 找到元素 3
            }
    2、std::sort：排序*
            int arr[] = {5, 3, 8, 1, 2};
            std::sort(arr, arr + 5);
            bool compare(int a, int b) {
   	 return a > b;  // 自定义排序规则，从大到小
            }
            std::sort(arr, arr + 5, compare);
    3、std::reverse：反转顺序*
            int arr[] = {5, 3, 8, 1, 2};
            std::sort(arr, arr + 5);
    4、std::copy：拷贝元素
            int arr[] = { 1, 2, 3, 4, 5 };
            int arr2[5];
            std::copy(arr, arr + 5,  arr2);  

分辨常量指针和指针常量：从左向右读。
int a = 1;
int* const b = &a;
int const *c = &a;
b是一个const pointer，指针常量，这个指针的指向不能变(即指针存的地址不能变)。
c是一个pointer to const，常量指针，指向常量的指针(指针常量，最好不要用这个名字，容易混淆)，这个指针指向的对象的值不能变。
理解的时候从右向左理解，* const意思是const的pointer，const *的意思是pointer to const。
注意：只有常量指针(指向常量的指针)才能指向一个常量
例如：
const int a = 1;
int const *b = &a;//正确
int * c = &a;//错误

指针的值是一个地址，而不是对象。
所以赋值的时候要用：
        int a = 10;
        int* b = &a;

指针的值是一个地址，指针之间可以进行赋值以指向同一个地址。
        int* a = new int(1);
        int* b = a;

delete在什么情况使用：
1.在一个方法中如果用new创建了对象，那么在方法结束前要把它手动delete掉，不然就会内存泄漏。
2.如果一个指针本来指向一个对象，那么当指针指向另一个新对象的时候要先把旧的对象delete掉。
3.在一个方法中如果用new创建了对象，那么除了在方法结束前要把它手动delete掉之外，还要看这个对象内部是否还有指针，如果对象内部还有个动态数组，那么要在类的析构函数中释放这个动态数组。
注意：delete数组要用 delete[] arr。

宏定义只做文本替换而不做类型检查，容易导致运算优先级的问题和类型错误的问题：
// 内联函数
inline int add(int x) {
    return x + 1;
}
// 预处理宏
#define SQUARE(x) x + 1
int main(){
    int b = 2;
    int result_inline = Square(b) * Square(b); 
    int result_macro = SQUARE(b) * SQUARE(b);   // 运算优先级导致错误
}
函数的调用过程：跳转到函数体中-把函数上下文(一个寄存器)入栈-执行函数体-把函数上下文(同一个寄存器)出栈-返回调用点。
内联函数的优化：把函数嵌入到调用它的地方，不再跳转函数体，不再执行入栈出栈操作。

内联函数：在函数前加上inline，类中的成员方法默认是内联函数。
特点：
内联函数与宏定义类似，直接把函数体的内容复制到函数的调用处，省去了在栈中压入和压出局部变量的消耗，提高了执行效率。
内联函数与宏定义的区别：
1.宏定义不会做语法检查
2.宏定义可能会出现优先级错误
总结：内联函数比宏定义更安全
内联函数只能包含简单的操作，当包含循环、递归、switch等复杂操作时，编译器会自动取消内联。
优点：省去了函数调用的过程提高了执行效率。
缺点：是否内联由编译器决定而不是程序员。
虚函数一般不是内联的，因为内联在编译阶段实现，编译器在编译时不知道应该调用哪段代码。

用int arr[3] = {1,2,3}的方式创建的是静态数组，长度参数只能传常数，而常数必须在声明时赋值，所以输入的值无法赋值给常数，也就不能通过输入值来创建长度为n的静态数组。

引用相当于给一个变量取别名。本质是一个指针常量，被编译器特殊处理，可以直接给这个指针赋值而不是赋地址。
int a = 10;
int& b = a;  //编译器处理为int * const b = &a;
修改引用的值会直接去修改这个指针指向的对象的值，而不是指针的指向
int c = 20;
b = c; //编译器处理为*b = c;
例如：
	int a = 1;
	int b = 2;
	int& c = a;
	c = b;
	cout << a;	//输出2
c = b并不会修改引用c的指向(所以不会报错)，而是被翻译为了*c = b;也就是直接把a的值改变为b了。

普通指针和引用无法被常量赋值，只有常量指针才能指向常量。

函数指针：return_type (*pointer_name)(argument_type1, argument_type2, ...);
//初始化：
void (*fptr)(int， int) = &Func; 
或
void (*fptr)(int， int) = Func; 
或
void (*fptr)(int， int)；
fptr = Func;
//调用
(*fptr)(1);	//显示调用
fptr(1);	//隐式调用
注意：*pointer_name周围的括号是一定不能少的，不然会和函数声明混淆。

当想让一个函数作为方法的参数传入时，可以用函数名也可以用函数指针，两者完全等效(C++中允许函数作为一个参数传入)
void Func2(void func(int i)) {
    cout<< "函数"<< endl;
}
void Func3(void (*fptr)(int i)) {
    cout<< "函数指针"<< endl;
}
甚至可以给Func2传一个函数指针，给Func3传一个函数名，都可以运行。
这是因为单独的函数(非调用)会被解释为函数指针，这也是为什么cout << &Func << endl << Func << endl;输出的值相同。
指针作为函数的参数时，形参是一个临时创建的局部指针，指向实参指针。

函数指针使用样例：
void Func() {
    std::cout << "Func!";
}
void Func2(void FuncPara()) {}		//即使不适用函数指针，函数也可以这样作为参数传入
void Func3(void (*FuncPara)()) {}	//与Func2等效
int main()
{
    void (*FuncPtr)();			//定义函数指针
    FuncPtr = &Func;			//赋值
    (*FuncPtr)();			//调用
}

void* 是可以指向任意类型的指针。其他类型指针可以直接赋值给void*类型指针，而void*类型的指针想赋值给其他类型的指针需要强制转换。
void*类型指针只有强制转化为一个具体类型指针后才能用*访问其内存空间。

32位操作系统指针占4字节，64位操作系统指针占8字节

空类对象占1字节的原因：让空类对象有一个容身之地。
int main() {
    Empty e;  // Empty类中什么都没有，但如果是0字节那么栈后续的插入对象就乱套了，于是e占1字节
}

很多头文件中都存在一个命名空间std，例如iostream、vector、map等，用于区分用户自己定义的vector、map等对象。
所以STL容器的创建一般前方都有std::xxx，例如std::vector。

为什么链表的节点的指向下一个节点的物体是指针？：因为在结构体中不能有未完成的类型，所以在创建(节点)结构体类型时内部不能有未完成的这个(节点)类型，必须用指针指向。

在C++中，通常将程序的代码分为头文件（Header Files）和源文件（Source Files）。这两者在功能和用途上有明显的区别：
头文件（Header Files）：以 .h结尾，包含了类、函数、变量的声明，但不包含其实现。
源文件（Source Files）：以 .cpp结尾，包含了类、函数、变量的实际实现。
关系和作用：分离接口和实现：头文件提供了接口的声明，源文件提供了接口的实现。
头文件中include其他文件之后，源文件include头文件即可，而不需要再次include。
注意：头文件只是用来声明的，不参与编译，只是把里面的代码给复制到这个源文件里来。这意味着.h文件如果不被include则没有任何作用，而.cpp文件由于会被链接在一起，所以其中代码都起效。
例如：
//A.h
int a = 1;		//当A.h不被其他文件include时，这个全局变量是无效的。
//A.cpp
int a = 1;		//无论A.cpp是否被include，这个全局变量有效。

由于.h文件是通过include在编译阶段直接加在.cpp之中的，所以如果在源文件直接定义全局变量就会引起重定义链接错误。
故要在.h的全局变量前加上extern代表其只是一个声明而非定义，然后再在.cpp文件中定义。
// A.h
extern int a;     // 声明全局变量，而不进行初始化
// A.cpp
#include "A.h"
int a = 1;	       //像一个正常全局变量一样定义

在其他cpp文件中定义的全局变量，可以使用extern int xxx；来声明其存在并使用。
如果在.h文件中声明了(一般也是用extern)，则可在.cpp中进行定义(仅一次)或使用。

一个全局变量的作用域默认是整个程序， 加了static则变为静态全局变量，作用域仅限于这个源文件。
即如果在一个cpp中定义了全局变量，另一个cpp中可以直接extern int xxx来获取。但如果定义的是静态全局变量，则另一个cpp文件无法获取。

头文件循环引用问题：当A类有一个成员是B的引用或指针，B类也有一个成员是A类的引用或指针，在头文件中互相include<B.h>，include<A.h>的话就会产生头文件循环引用。
可以使用向前声明解决，即在各自的.h文件中不引入对方.h，而仅提前声明，然后在.cpp中引入对方.h文件。
例如：
// ClassA.h
class B;  // 前向声明
class A {
    B* b_ptr;  // 只需要不完整类型声明
public:
    void doSomething();
};
// ClassB.h
class A;  // 前向声明
class B {
    A* a_ptr;  // 只需要不完整类型声明
public:
    void doSomething();
};
// a.cpp
#include "a.h"
#include "b.h"  // 在实现文件中包含完整定义
void A::doSomething() {
    b_ptr->doSomething();
}
// b.cpp
#include "b.h"
#include "a.h"  // 在实现文件中包含完整定义
 
void B::doSomething() {
    a_ptr->doSomething();
}

new/delete和malloc/free都是用于向堆中申请空间的方法，两者的区别：
	int* a = new int();
	int* b = (int*)malloc(sizeof(int));
1.new/delete是C++的操作符；malloc/free是C的库函数。
2.new会自动计算所需空间的大小(根据new后跟的类型，例如此处的int)；malloc要手动设置所需空间的大小。
3.new直接返回一个对应类型的指针，malloc申请成功后返回一个void*(void类型的指针)，需要强制转化为对应类型的指针。
4.new失败会抛出异常，malloc失败会返回NULL。
5.new会先调用操作符new(然后调用构造函数)，而操作符是可以被重载的，所以new可以被重载去定义自己的内存分配规则(例如在全局区中分配而不在堆中)。
6.new会先开辟内存空间，然后调用构造函数；malloc只会开辟内存空间。delete会先调用析构函数，然后释放空间，free只释放空间。
7.请勿混用。
用法区别：
// C++方式
int* a = new int(5);
delete a;         // 对 new 使用 delete
int* arr = new int[10];
delete[] arr;     // 对 new[] 使用 delete[]
// C方式
int* b = (int*)malloc(sizeof(int) * 10);
free(b); 

如果类实例化在了堆上，需要用delete手动释放，释放时类会调用它的析构函数
如果类实例化在了栈上，则作用域结束时类会被自动释放，释放时类会调用它的析构函数。
即所有使用new创建的资源都必须要手动释放，类中new创建的资源还需要在类的析构函数中释放。

C++中的作用域：
同层次之间作用域是封闭的：
int main() 
{
        {
                int a = 1;
        }
        {
                cout << a;	//报错
        }
}
内层作用域能访问外层作用域的变量，也能再次定义外层作用域的变量(覆盖掉外层作用域的变量)，但再次定义的变量只在内层中生效：
int main() 
{
        int a = 1;
        {
                int a = 2;
                cout << a;	//输出2
        }
        cout << a;	//输出1
}

static修饰一个局部变量：
int func() {
        static a = 0; // 使用static关键字定义静态局部变量，在首次调用时初始化
        a += 1;           // 在每次函数调用时改变值
        return a;
}
int main() {
        cout << func() << endl; // 输出 1（首次调用初始化）
        cout << func() << endl; // 输出 2（每次调用值发生变化）
        return 0;
}
被修饰的局部变量会被存在全局区中，该变量仅在第一次调用该函数时被初始化，之后不再执行初始化语句。
自此static共有三种用法，分别修饰类成员、全局变量、局部变量。

在一些不希望存在构造函数的类中，使用以下方法防止编译器自动生成构造函数：
class A {
public:
        A() = delete;
}

字节对齐：
class B {		//B大小为16字节，因为最大是8字节，
private:
        double b;
        int c;
}

程序在运行时在虚拟内存中划分出栈、堆、全局、代码区等区域。其中栈和数据结构的栈相反，是从上向下/从高地址到低地址增长。


二叉搜索树：左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。
    搜索效率为O(logn)，在顺序插入时恶化为O(n)

自平衡二叉搜索树(平衡二叉树)是通过自我调整机制保持高度平衡，从而确保操作的高效性的二叉搜索树，有AVL 树和红黑树两种。

AVL树是一种自平衡的二叉搜索树，它通过在插入和删除操作后进行旋转来保持树的平衡，关键特性是每个节点的左右子树的高度差（即平衡因子）不能超过1。

红黑树是一种自平衡的二叉搜索树，它通过在插入和删除操作时执行特定的操作来保持树的平衡。红黑树的每个节点都被标记为红色或黑色，并且遵循以下性质：
1.根节点是黑色的。
2.每个叶节点（NIL节点，不带有元素）是黑色的。
3.不能有两个连续的红节点。
4.从任一节点到其每个叶节点的所有简单路径都包含相同数目的黑色节点。
关键特性是其最长路径中结点个数不会超过最短路径结点个数的两倍。

AVL树 vs 红黑树
平衡性：
        AVL树：更严格的平衡，左右子树的高度差不超过1。
        红黑树：较松散的平衡，确保从任一节点到叶节点的路径中黑色节点数量相同。
旋转操作：
        AVL树：插入和删除时可能需要更多的旋转操作来保持平衡。
        红黑树：插入和删除时的旋转较少，调整操作简单。
查找性能：
        AVL树：查找操作性能较好，因为树的平衡更加严格。
        红黑树：查找稍逊于AVL树，但仍保持 O(log N) 的性能。
插入和删除性能：
        AVL树：插入和删除时可能需要多次旋转，性能稍差。
        红黑树：插入和删除性能较好，旋转操作较少。
应用场景：
        AVL树：查找操作较频繁的场景。
        红黑树：插入和删除操作较频繁的场景（如STL的 std::map 和 std::set）。

常见数据结构性能：
			插入		删除		查询		随机访问
数组			O(n)		O(n)		O(n)		O(1)
链表			O(1)		O(1)		O(n)		O(n)
红黑树			O(logn)		O(logn)		O(logn)		O(logn)

C++中char[]的长度用sizeof(crr)求，求得的长度会是正常长度+1，因为字符串常量末尾会自动加上结束符\0。

C++的栈默认只有1MB(C#应该也是)，可以在VisualStudio中调整。而C++是允许在栈上创建数组的，所以int arr[260000];会直接报错栈溢出。
所以C++中较大的数据结构建议创建在堆上而不是栈上。

sizeof()关键字输出的是这个变量所占字节的大小，所以
int arr[100]；
char crr[100];
sizeof(arr);//400
sizeof(crr);//100

在C++中，数组是不能给数组赋值的，crr = crr2;是错误的。
但当向实参和形参都为数组时，编译器会用一个指针来接收数组
例如：
void Func(int arr[]) {
    cout << sizeof(arr);		//输出的是4而不是数组的字节数
}

C++位运算中只有异或符号^而没有同或，同或可以用~(a ^ b)表示。
其他位运算符：
        &：按位与，对应位置上的两个操作数都为 1 时结果为 1，否则为 0。
        |：按位或，对应位置上的两个操作数中只要有一个为 1，结果就为 1。
        ^：按位异或，对应位置上的两个操作数不相同则结果为 1，相同则结果为 0。
        ~：按位取反，将操作数的每一位取反，即 0 变为 1，1 变为 0。
        <<：左移运算符，将操作数的所有位向左移动指定的位数，实际上就是乘以二。
        >>：右移运算符，将操作数的所有位向右移动指定的位数。实际上就是除以二。
        C#中也有这些运算符。

使用cmath库的pow方法来获取幂。

常量指针能指向变量，普通指针不能指向常量。

STL的erase(iterator i)方法删除元素会使当前迭代器失效并返回指向下一个元素的迭代器iterator，所以正确的在遍历中使用erase的方式是：
        vector<int> vec{1,2,3,4,5};
        for (vector<int>::iterator i = vec.begin(); i != vec.end();) {
                if (*i == 3)
                        i = vec.erase(i);		//获取删除后返回的迭代器
                else
                        i++;
	}
        }

将数字字符串转为数字类型：使用string库的stoi(str)方法
        #include <iostream>
        #include <string>
        using namespace std;
        int main() {
	string s = "123";
	int i = stoi(s);
	cout << i;
        }
若字符串中存在非数字则会报错。
string库中还有stol/stof/stod等转long/float/double类型的方法。

字符数组转字符串：用构造函数或赋值运算符可直接转换
        char arr[] = "Hello";
        string str(arr);		//构造函数
        str = arr;		//赋值运算符
字符串转字符数组：使用c_str()方法把字符串转化为const char*，再用strcpy(arr, str)把const char*复制到字符数组中。
        std::string str = "Hello";
        char arr[100];
        strcpy(arr, str.c_str()); 	//c_str()方法获取一个字符串的const char*格式
       
int转string类型：使用string库的to_string(num)方法
        int num = 123;
        string str = std::to_string(num);  // "123"

char转string类型：使用string的构造方法
        char c = 'A';
        string str(1, c);//1是字符串长度

检测一个字符char是否为空：
if (vec[0] == '') 	//这是错误的
if (vec[0] == '\0')  //这是正确的

int main(){
    char c = 'M';
    char s1[] = { 'M','o','n','d','a','y' };
    char s2[] = "Monday";
    int num[] = { 1,2,3 };
    char* cpt = &c;
    char* spt1 = s1;
    char* spt2 = s2;
    int* numpt = num;
    cout << cpt << endl;		//输出M烫烫??帔 ，是乱码 
    cout << spt1 << endl;		//输出Monday烫烫烫烫烫烫蘉烫烫M?p鹽 ，是乱码
    cout << spt2 << endl;    		//输出Monday ，是正确的输出
    cout << numpt << endl;		//输出00D9FA90 ，是地址
}
原理：
1.cout一个char类型会将其当做一个C风格的字符串(以\0结尾)，于是会一直输出乱码到找到一个\0才停止输出，所以想要输出一个char类型需要char str[] = { c, '\0' };然后输出str。
2.cout字符指针并不会正常输出指针指向的地址(输出int指针会输出地址)，而是输出指针指向地址存的字符，并且会从该字符位置开始向后读取，直到遇到结束符号'\0'才会停止。
3.以字符串赋值字符数组，字符串末尾会自动加上\0结束符。以字符数组赋值字符数组变量，字符数组末尾不会自动添加\0结束符，于是会输出乱码直到遇到\0。
注意：在用初始化列表初始化字符串数组时记得最后一个元素填\0。

在C++中，实现多态有以下三种方式：
	虚函数（Dynamic Binding）
	函数重载（Function Overloading）
	模板（Templates）

不能声明为虚函数的有：普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。

使用xxx() = delete;删除默认生成的函数，使用virtual xxx() = 0声明纯虚函数。

除了类模板，函数也可以使用模板：
template <typename T>	//typname与class等效
T square(T val) {
    return val * val;
}
square<int>(5);	//正常调用
square(5)		//自动推导

友元函数：让某个全局方法可以访问该类的所有成员，当某个函数与类关系密切，但不适合作为成员函数，就定义为友元函数，例如一个类的输出运算符<<。
    样例：
        #include <iostream>
        using namespace std;
        class Box {
        private:
            double width;
        public:
            Box(double w) : width(w) {}
            // 声明友元函数，允许重载 << 运算符访问 Box 的私有成员
            friend ostream& operator<<(ostream& os, const Box& b);
        };
        // 友元函数实现，重载 << 运算符
        ostream& operator<<(ostream& os, const Box& b) {
            os << "Box width: " << b.width;
            return os;
        }
        int main() {
            Box box(10);
            cout << box << endl;  // 使用重载的 << 运算符输出 Box 的信息
            return 0;
        }
    0.友元函数的作用是访问一个对象的private和protected成员，普通函数传入对象只能访问其public成员
    1.友元函数要先在类中用friend声明，然后直接实现或是在类外实现都可以
    2. 友元函数中必须要有一个类对象的指针(或引用)作为参数
    3.友元函数不是类成员，函数中不能使用this指针
    4.友元函数不能被继承
    5.友元函数相当于是一个全局函数，即使在类中声明并定义，也可以像全局函数一样被全局调用
    6.友元函数可以是一个全局函数，也可以是另一个类的成员函数

友元类：让另一个类可以访问该类的所有成员，一种很强的开放性关系。
        class A {
                int a;
        public:
                A(int val) : a(val) {}
                friend class B;  // 将类 B 声明为友元类
        };
        class B {
        public:
                void printA(A& obj) {
                        // 类 B 可以访问类 A 的私有成员
                        std::cout << "Value of A's private member: " << obj.a << std::endl;
                }
        };

异常处理与自定义异常类：在可能出错的地方抛出自定义的错误类型
         class DatabaseConnectionException exception {
         public:            
                  const char* what() {			
                           return "Failed to connect to database";	
                  }
         };
         int main() {
                  try {
                           xxxxxxxx				//连接数据库的流程
                           throw DatabaseConnectionException();	//流程一旦失败就抛出自定义错误
                  }
                  catch(DatabaseConnectionException e){
                           cout << me.what();
                  }
         }

函数在A.cpp文件中定义，在B.cpp文件声明，就可以在B.cpp文件中使用。
变量在A.cpp文件中定义，在B.cpp文件中使用extern int a声明;，就可以在B.cpp中使用该变量。
在两者前面加上static都会使其具有内部链接性，让其只能在当前的cpp文件中使用。

一定不要include .cpp文件！因为每个.cpp文件都会被编译为独立的obj文件然后链接在一起。
如果A.cpp包含(include)了B.cpp，那么B.cpp的代码会被拷贝进A.cpp中，于是B.cpp会被编译两次，出现重定义的链接错误！


指针之间可以做减法来确定两者之间的距离，STL中容器的迭代器也可以。
int main() {    
        int arr[] = { 1,2,3,5,6 };
        int* ptr1 = &arr[1];
        int* ptr2 = &arr[3];        
        int tmp = ptr2 - ptr1;
        cout << tmp;		//输出两者之间的元素个数2，如果反转被减数和减数得到-2
}
注意：此做法仅限于同一个数组之间。

重载++运算符：
前缀++：
class A{
private：
    int value = 1;
public:
    A& operator++() {
        value ++;  // 递增对象的状态
        return *this;  // 返回递增后的对象本身的引用
    }
}
后缀++：
    A operator++(int) {
        A tmp(*this);
        value ++;  // 递增对象的状态
        return tmp;  // 返回递增后的对象本身的引用
    }
前++返回的是引用，后++由于返回的是局部变量故只能返回值。
为了区别前++和后++，在后++的参数中有一个int类型的标识。
由于后++返回的是值，所以(a++)++这种操作是会报错的。

char crr[] = "123";  crr的实际长度为4，因为自动添加了结尾符\0。

奇奇怪怪的字符类型char：
    char crr[] = "123";		//正确
    char* cptr = "132";	//错误
    const char* ccptr = "123";	//正确
    char[]数组将字面值常量复制到栈中，可以对其进行修改。
    char*作为指针指向字面值常量的存储地址，而字面值常量禁止被修改，所以char*要加上const才允许指向字面值常量

字符数组之间的比较要使用STL中的方法strcmp(arr1, arr2)，返回值为负则第一个串的第一个不同字符上阿斯克码更小，返回0则两字符数组相同，返回正值和负值结果相反
    char crr[] = "123";
    char crr2[] = "123";
    if (strcmp(crr, crr2) == 0) {		//正确的比较方式
        cout << "???";
    }
    if (crr == crr2) {			//不会报错，但是比较的是两个指向第一个元素的指针的地址，肯定是不一样的
        cout << "???";
    }
字符数组之间的复制要使用STL中的strcpy(target, source)方法，因为数组指向无法改变
   crr = crr2;	//报错，因为数组名被解释为指针常量，指向的东西无法改变
   crr = "345";	//也会报错，因为初始化后无法改变指针的指向
   strcpy(crr, crr2);	//正确的复制方式
注意：如果被复制的数组长度大于容器数组，则会报错
   char crr[5];         		// 目标数组，最多只能存放4个字符 + '\0'
   char crr2[] = "Hello"; 	// 实际是 "Hello\0"，长度为6
   strcpy(crr, crr2);    		// ❌ 溢出了！crr 只有 5 字节空间

全局常量、全局静态常量、字符串常量会存放在常量区。
而局部常量、常量成员不会放在常量区。
所以：
class A {
        const int v = 1;
        int arr[v];	//报错，因为编译时v还没被赋值
};

精度陷阱问题：浮点数以二进制存储，这导致不是所有的十进制小数都能被精确地表示。
精度陷阱例子：累加1000次0.01只能得到99.999
        int main() {
	float sum = 0.0f;

	// 累加1000次
	for (int i = 0; i < 1000; ++i) {
		sum += 0.1f;
	}

	std::cout << "Expected result: " << 1000 * 0.1f << std::endl;	//预期值为100
	std::cout << "Actual result: " << sum << std::endl;		//实际值为99.999
	return 0;
        }
所以比较两个浮点数一般使其相减再比较一个较小的误差：
        const float EPSILON = 1e-6f;
        if (std::fabs(sum - 1000.0f) <= EPSILON) {	//fabs取double类型绝对值，abs取int类型绝对值，fabsf取float类型绝对值
                std::cout << "是1000！" << std::endl;
        } else {
                std::cout << "不是1000！" << std::endl;
        }

C++10的x次方写作1ex
例如：
        int main() {
	int tmp = 1e4;
	float tmp2 = 1e-2;
	cout << tmp << endl;	//输出10000
	cout << tmp2 << endl;	//输出0.01
	return 0;
        }

双重指针：即指向指针的指针，存的值是指针的地址。
        用途1：在函数中修改指针的指向
	void Func(int* tmpPtr ){
	         tmpPtr  = new int(100);
	}
                void Allocate(int** tmpPtr ) {
                        *tmpPtr  = new int(100);
                }
                int* p = nullptr;
	Func(p)		// 无法改变指针指向，传入 int* 类型，实际语法类似int* tmpPtr = p。tmpPtr 只是和 p 指向了同一块空间(nullptr)，改变 tmpPtr 的指向并不能改变 p 的指向和值
                Allocate(&p);	// 成功改变指针指向，传入 int** 类型，改变*tmpPtr 的指向改变的就是 p 的指向
                std::cout << *p << std::endl;  // 输出 100
        用途2：动态二维数组
                int rows = 3, cols = 4;
                int** matrix = new int*[rows];  // 每行是一个 int* 指针
                for (int i = 0; i < rows; ++i) {
                        matrix[i] = new int[cols];  // 每行分配列
                }

在大多数地方，数组可以看做指向它的第一个元素的指针：
        int main() {
	int staticArr[5]{ 1,2,3 };

	int* dynamicArr = new int[5]{ 1,2,3 };
	cout << *(staticArr + 2);	//输出3
	cout << *(dynamicArr + 2);	//输出3
        }

指针数据与数组指针
    *指针数组：本质是一个数组，其中的每个元素都是指针。每个指针可以指向一个特定类型的数据或对象。
        int a = 10, b = 20, c = 30;
        int* arr[3];  // 声明一个包含3个int指针的数组
        arr[0] = &a;
        arr[1] = &b;
        arr[2] = &c;
        for (int i = 0; i < 3; ++i) {
            std::cout << *arr[i] << " ";  // 输出 10 20 30
        }
    数组指针：本质是一个指针，数组指针是指向数组的指针，它指向整个数组而非数组的第一个元素。
        int arr[5] = {1, 2, 3, 4, 5};
        int (*ptr)[5] = &arr; // 声明了一个指向包含5个整型元素的数组的指针
        (*ptr)[0] = 10;

用指针数组可以创建二维数组：
    int* arr[3];
    for (int i = 0; i < 3; ++i) {
        arr[i] = new int[4];  // 每行是一个一维数组
    }
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 4; ++j)
            arr[i][j] = i * 10 + j;
也可以用双重指针在堆上创建二维数组：
    int** arr = new int*[3];    
    for (int i = 0; i < 3; ++i) {
        arr[i] = new int[4];  // 每行是一个一维数组
    }
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 4; ++j)
            arr[i][j] = i * 10 + j;

在栈上创建最简单的二维数组：
    int arr[3][4]{ {1, 2},{1,2} }; 	// 完全在栈上，类型是 int[3][4]
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 4; ++j)
            std::cout << arr[i][j] << " ";
            std::cout << "\n";
        }
    }
注意：如果使用了初始化列表赋初始值，那么所有未提及到的元素都会被设置为0，是一个很方便的初始化方式。

C风格的字符串是以\0结尾的字符串，类型为char[]以及char*。
C++风格的字符串是封装好的string类，功能更为强大，使用更为方便。

string提供的构造函数和赋值运算符可以把任何C风格字符串作为参数来创建string字符串。
    char arr[] = "hello";
    char* p = arr;
    const char* cstr = "Hello, world!";
    std::string str1 = arr;
    std::string str2 = p;
    std::string str3 = cstr;


--------------------------------------------------------------------------二、类与对象--------------------------------------------------------------------------
C++中类可以创建在栈上或创建在堆上，唯一的区别是 是否使用new！
Student stu = Student();		//标准写法，创建在栈上。
Student stu;			//缩略写法，也会调用构造函数，只有创建在栈上才能用这个写法！
Student stu();			//坑爹写法，仅仅声明了一个返回值为Student的方法，而不是定义
Student stu(c, 15, 92.5f);		//有点坑爹的写法，虽然是正常调用了构造函数
Student* pstu = new Student();		//创建在堆上，没有缩略写法！
Student* pstu = new Student(c, 15, 92.5f);	//创建在堆上，没有缩略写法！
注意：
创建在堆上的类对象new的返回值是一个指针，必须要用指针来接收这个值。同时这意味着存在堆上的类要用指针才能调用，指针调用一个类的的成员要用->。
创建在栈上的类对象的赋值操作是值拷贝，改变其中一个类的值另一个类不会改变。

相比C#，C++可以把类方法的[实现]写在类外，只需要在前面加上作用域，但是记得要先在类中声明：
class Student {
public:
 Student();
};
Student::Student() {
    ...
}
而C#不支持方法的声明和实现分离。

拷贝构造函数是一种特殊的构造函数，与一般构造函数的唯一区别就是拷贝构造函数传的参数是(const Student& stu)，即一个被const修饰的该类实例的引用。
至于为什么要加const，一是因为传来的参数是用来赋值的，防止修改原始参数，二是因为使用const的话可以接收const参数和非const的实参，而不用的话实参就只能传非const实参(因为作为一个指针，只能指向非常量)。
至于为什么是引用，因为如果是对象，那么形参复制实参时会递归地调用拷贝构造函数(而创建引用可以看做创建一个指针，指向一个变量并不会调用拷贝构造函数构造一个新对象)。

拷贝构造函数写法：
	Person(const Person& person) {
		cout << "拷贝构造！";
		...
	}
=运算符重载写法：
	Person& operator=(const Person& person) {
		cout << "赋值运算符重载！";
		...
	}

拷贝构造函数在什么情况下会被调用？
    1.使用已有的对象创建新对象时：
        Student* s1 = new Student("aaa");
        Student* s2 = new Student(*s1);		//拷贝构造函数
    或
        Student s1("aaa");
        Student s2(s1);
        Student s3 = s1;			//拷贝构造函数
        s3 = s2;				//赋值操作符
注意：可以自定义拷贝构造函数以实现深拷贝。
    2.在函数参数值传递时：
        void Func(Student s) {
    	...
        }
        int main(){
            Student* s1 = new Student("aaa");
            Func(*s1);
        }
注意：默认拷贝构造函数和赋值操作都是浅拷贝。
注意：C#已不再提供默认拷贝构造函数
注意：Student* s = &s1;不是拷贝，而是指针的赋值。

类实例被创建时会带有默认的拷贝构造函数，这个默认的拷贝构造函数会执行浅拷贝，也就是把栈中成员的值进行一次拷贝。
在某些情况下我们希望深拷贝，这时需要自定义拷贝构造函数。
什么时候需要自定义拷贝构造函数？
    1.类中有指针类型成员（动态分配内存）。
    2.类中有特殊资源管理对象（如文件、数据库连接）。

自定义拷贝构造函数例子：当类中存在指针时
    MyClass(const MyClass& other) {
        num = new int(*other.num)
    }

this是一个指针，指向被调用的成员函数所属的对象。

类的初始化方式之一 —— 初始化列表：
    Student::Student(int id, int age):id(id),m_age(22),name("chen") {
        ...
    }
使用初始化列表的情况：
    1.类成员有常量
        注意：非必须，也可在定义时直接赋值。但是若想要通过外部参数赋值，就必须用初始化列表而非构造函数。
        常量有全局常量、类成员常量、局部常量三种。除了类成员常量，其他两种都必须要在定义的时候初始化。
        而类成员常量除了可以在定义时初始化也可以用初始化列表进行初始化，但是不能在构造函数中赋值。初始化和赋值是不同的，构造函数中是在赋值而不是在初始化。
    2.类成员有引用(引用即特殊的指针常量)
        注意：非必须，也可在定义时直接赋值。但是若想要通过外部参数赋值，就必须用初始化列表而非构造函数。
        引用成员需要在定义的时候初始化或者在初始化列表中初始化，而不能在构造函数中初始化。
    3*.在子类的构造函数中想要调用父类特定的有参构造函数而不是默认构造函数
        注意：这个是必须的，不然只会调用父类的默认构造函数，而不是有参构造函数。
        使用方式：Son():Father(1){}
初始化列表使用样例：
    class MyClass
    {
    private:
        const int year;
        const int month;
        const int day;
    public:
        MyClass() :year(1),month(2),day(3){}		
    };

类的静态成员是被该类共享的，所以不适合在类中对其进行初始化，不然每个新创建的类都会重复初始化该类共有的静态成员。
所以静态成员只能并且必须要在类外进行初始化，且最好不要在.h而是在.cpp中初始化。
例子：
class CC {
public:
    static int b;
};
int CC::b = 3;
初始化后可以用CC::b的形式获取，也可以直接用类的实例cc.b获取。
而在C#中静态成员可以随时随地被赋值。并且只能被用CC.b的方式获取。

当父类的方法不是虚方法时，子类中的同名方法不会干扰父类中的方法。
class Base{
public:
	 void printError(){  //使用virtual关键字声明函数，将其变为虚函数，即可使用多态
	 cout << "基类方法!" << endl;
	 };
};
//派生类
class Derived : public Base{
public:
	 void printError(){
		cout << "派生类方法!" << endl;
	}
};
void test()
{	
	Base *ex = new Derived(); //静态联编导致子类对象调用基类方法，而不是子类方法
	ex->printError(); //输出基类方法！
}
而当父类方法前添加virtual关键字的话，子类中的同名方法会重写父类的方法，就能使用多态。

当把一个派生类实例赋给一个基类对象(而非指针)时，会发生对象切片(object slicing)，只保留父类的属性和方法，即使使用了virtual关键字也会导致调用的方法变为基类方法。
void test()
{	
	Base e = Derived(); //对象切片导致子类对象调用基类方法，而不是子类方法
	ex.printError(); //输出基类方法！
}
-----------------------------------多态-----------------------------------
多态分为静态多态和动态多态。
静态多态也叫编译多态，由函数重载实现。动态多态也叫运行多态，由函数重写实现。
多态实现的条件：
1.父类方法有virtual关键字，子类中有同名方法去重写(C++中不需要override关键字)
2.用父类的指针(或引用)指向子类对象，调用子类重写的虚函数

🎯 一句话总结：多态允许使用基类指针或引用来调用子类的重写方法,从而使得同一接口可以表现不同的行为。
你可以只用子类指针没问题，但只适合你“明确知道类型”的场合。
而多态是为了解耦，让程序“处理未知类型的子类”时依然能工作。

当不使用多态时，子类对象的创建的顺序是：父类构造函数-子类构造函数-子类析构函数-父类析构函数。
当使用多态的时候，需要把父类指针的析构函数设置为虚函数，这样的话在delete父类指针时会先调用子类的析构函数，再调用父类的析构函数。不然只会调用父类的析构函数。

当一个类中存在虚函数时，编译器会为该类生成一张虚函数表（vtable）。这是一张静态的、由函数指针组成的数组，每个指针指向该类中一个虚函数的具体实现地址（位于代码区）。
在运行时，每个对象内部会被自动插入一个 虚表指针（vptr），它指向该类的虚函数表这也是为什么含有虚函数的类，其对象大小通常会比不含虚函数的类大——因为它多了一个指针成员（vptr）。
虚函数存在代码区中和普通函数在一起。虚函数表存在静态/全局区中。虚函数指针存在类的实例中。

多态实现的原理：
1.在编译时，如果父类有虚函数表，则父类和子类都会有自己的虚函数表，如果子类重写了虚函数，则会在虚函数表中用自己重写的函数的位置代替父类虚函数的位置。如果子类自己还有虚函数，则在虚函数表末尾加上自己的虚函数。
2.在运行时，会产生一个虚函数表指针指向该类的虚函数表，而由于虚函数表中父类虚函数在编译时就已经被替换了，就完成了多态。
即：类的虚函数表+对象的虚函数表指针实现了多态。

构造函数可以是虚函数吗？：不能。
因为虚函数实现所依赖的虚函数表指针要靠构造函数来创建，如果构造函数还没运行，就没有虚函数表指针，也就无法调用虚函数。
静态函数可以是虚函数吗？：不能。
因为静态函数在编译时确定，虚函数在运行时才能确定。

类的空指针也能调用类的成员方法：
class base {
        int a;
public:
        void fun() {
                cout << "normal";
        }
        void  fun2(){
                cout << a;
        }
        virtual void fun3() {
                cout << "virtual";
        }
};
int main() {
        base* b = NULL;
        b->fun();	//正常！
        b->fun2();	//报错！
        b->func3() 	//报错!
}
原因：
    类方法调用原理为：base::fun(b)。因为类的方法是所有类实例共享的，调用类的方法时隐式地传入了调用类方法的类对象(以区分不同对象的数据，例如此处的a)，
    而如果方法中不通过this访问类的成员(就算是不通过this直接访问类的成员也不行)，那么this是否为空也就不会影响方法的执行，所以fun方法不会报错，而fun2方法会报错。
    fun3是虚方法，要通过对象的虚函数表指针找到虚函数表来调用，但是指针已经为空自然就找不到虚函数表，也就找不到虚函数，报错了。
注意：C#中引用和这里的指针已经不是一个东西了。Father father;声明一个Father类的引用，该引用在被实例化之前都无法调用其中的方法。
------------------------------------------------------------------------

子类调用父类的方法(即使子类重写了父类方法也可以调用)：
1.在类方法中：
    void Func() {
        Father::Func();
        cout << "son";
    }
2.用子类实例调用：
    Son son = Son();
    son.Father::Func();
类比C#只能在类方法中使用base.Func()调用父类方法

编译器给类自动生成的四个函数：默认构造函数、拷贝构造函数、赋值函数、析构函数。(C#中应该只有默认构造函数)

结构体和类都可以选择实例化在堆上或在栈上，他们都可以继承、实现函数、实现多态，作用几乎相同。(C#中结构体是值类型，只能存在栈中，不支持继承，成员默认访问权限是private)
唯二的不同：
class成员的默认访问级别是private，struct成员的默认访问级别是public。
class继承的默认方式是private，struct继承的默认方式是public。
即：结构体是轻量级的类，设计的默认权限和默认继承权限都是public，在存储的数据不多，函数不复杂时可以使用结构体。

public继承：父类中各成员不变。(也是C#的继承方式)
protected继承：父类中public成员对于子类变成protected。
private继承：父类中public、protected成员对于子类变成private。

当一个类继承自两个类，且这两个类有相同的成员名，则需要标明作用域：
#include <iostream>
using namespace std;
class A {
public:
        int value;
        A(int v) : value(v) {}
};
class B {
public:
        int value;
        B(int v) : value(v) {}
};
class C : public A, public B {
public:
        C(int a_value, int b_value) : A(a_value), B(b_value) {}
        void printValues() {
                cout << "A's value: " << A::value << endl;
	cout << "B's value: " << B::value << endl;
        }
};
int main() {
        C obj(10, 20);
        obj.A::value = 3;
        obj.printValues();  
        return 0;
}

菱形继承问题：两个子类继承自一个父类，同时又有一个孙子类同时继承这两个子类。
  A
 / \
B   C
 \ /
  D
后果：导致孙子类中变量具有二义性。d._a报错，不知道是从B来的还是从C来的。即使没有A，当B和C成员同名时也有这个问题。
解决方式：
1.标明成员的作用域，像上一个问题那样解决。
2.让类B/C虚拟继承A
    #include <iostream>
    using namespace std;
    class Base {
    public:
        int value;
        Base(int v) : value(v) {}
    };
    class A : virtual public Base {
    public:+
        A(int v) : Base(v) {}
    };
    class B : virtual public Base {
    public:
        B(int v) : Base(v) {}
    };
    class C : public A, public B {
    public:
        C(int a_value, int b_value) : A(a_value), B(b_value) {}
        void printValue() {
            // 直接访问 value，因为只有一个 Base 类实例
            cout << "value: " << value << endl;  // 此时 value 来自 Base
        }
    };
    int main() {
        C obj(10, 20);
        obj.printValue();  // 输出 value
        return 0;
    }

类的静态成员是被该类共享的，所以不适合在类中对其进行初始化，不然每个新创建的类都会重复初始化该类共有的静态成员。
所以静态成员只能并且必须要在类外进行初始化，且最好不要在.h而是在.cpp中初始化。
例子：
class CC {
public:
    static int b;
};
int CC::b = 3;
初始化后可以用CC::b的形式获取，也可以直接用类的实例cc.b获取。
而在C#中静态成员可以随时随地被赋值。并且只能被用CC.b的方式获取。

在子类中调用父类方法的同名方法：
class Son: public Father {
public:
        void Func() {	//同名方法	
        }
        void Test(){
                Father::Func()
        }
};
即使是被重写的virtual方法也可以被调用。
而C#中使用base.xxx()的方法向上寻找匹配的方法。

C++的重写不需要override关键字，非要加的话override关键字要写在方法后面：
       void  Func() override {		
              cout << "son";
       }
这是很奇怪的。

C++类中的this是一个指向当前对象的指针，所以赋值要用this->c = 1;
而C#中没有指针概念，this就是当前对象，赋值可以直接使用this.c = 1;

抽象类：至少含有一个纯虚函数的类，不允许被实例化。
纯虚函数：在函数声明后加“=0”，
class Shapes   //抽象类
{
protected:
    int x, y;
public:
    void setvalue(int d, int w=0){x=d;y=w;}
    virtual void disp()=0;//纯虚函数
};
抽象类不允许被实例化，其子类如果不重写纯虚函数的话其也作为一个抽象类存在，。
而在C#中，一个函数用abstract修饰变为纯虚函数，拥有纯虚函数的类必须用abstract修饰变为抽象类，这样的类也不允许实例化。
其子类如果不重写纯虚函数，就只能在类前加上abstract变为抽象类。

const加在成员函数之后表示在该成员函数是常函数，在其中不允许修改成员变量：
class Father {
public:
        int c = 1;
        void Func() const	//记住是之后而不是之前
        {
                c = 2;	//报错，因为修改了成员变量
        };
};

初始化列表中，先声明的值先被赋值：
class Base {
public:
       int   i;				//声明顺序是先i
       int   j;				//后j
       Base(int  value) : j(value), i(j) 	//初始化列表的先后没有作用
       {
       }
};
因为i先被声明，所以i会先被赋值，由于此时j是未赋值的，所以i输出为-858993460，即VS中int类型的默认值。
如果i、j声明顺序反转，则i、j都能被正确赋值value。

类A中若存在自定义类B类型的成员对象，则在类A实例化时，在A的构造函数调用前会先调用B的构造函数。
如果不指定则调用无参构造函数。
当然也可以在初始化列表中指定B的构造函数：
    A(int val) : b(val) {  
        std::cout << "A's constructor called!" << std::endl;
    }
如果不想在此时调用，则需要把类B成员改为B指针，在构造函数或别的地方调用B的构造函数。
//C#中由于所有类都相当于指针，所以实例化A不会调用类B的构造函数。即使B是一个结构体也不会调用B的构造函数。

使用expicit(明确的)修饰的构造函数变为显式构造函数，作用是防止编译器调用构造函数时进行隐式类型转换。
正常没有explicit修饰时：
class PartTool {
public:
        int value;
        void Func() {
                cout << value;
        }
        PartTool(int a):value(a){}
};
int main() {
        PartTool pt1 = 2;	//将int类型隐式转化为PartTool类型
        PartTool pt2(2)		//在使用explicit后只能正常显式地调用构造函数
        pt.Func();
}
显式构造函数主要用于确保代码在创建对象时是显式、明确的。这样能清楚地知道每次对象的创建方式，从而减少了可能的错误和不清晰的行为。

类模版：在类前一行加上template<class T1, class T2>即可
        template<class T1, class T2>
        class A { 
	xxx
        }
C#中直接在类名后面加：
        class MyClass<T>
        {
        }

当函数的参数是对象时，在函数定义之前必须有对象的完整类型信息
        class Man;
                void MyFunc(Man man) {		//报错，因为定义Man对象时，必须要告诉编译器Man如何构建
        }			
        void MyFunc(Man& man) {		//不报错了，因为仅仅是声明一个指针
        }	

如果在方法中使用值传递传对象的话，在方法结束时会调用形参的析构函数，导致实参中的指针成员被释放，所以最好不要用值传递来传对象。
class A {
public:        
        int* age;
        A(int value) {
                age = new int(value);
        }
        ~A() {
                delete age;
        }
        void PrintAge() {
                cout << *age << endl;
        }
};
void Func(A a) {		//以值传递传对象
        cout << "Func" << endl;
}			//作用域结束时调用A的虚析构函数
int main() {
        A a = 8;
        Func(a);		
        a.PrintAge();		//输出乱码，因为age指针已经被上一行释放了
}

当一个基类指针指向派生类对象，可以使用dynamic_cast<Derived*>(basePtr)将该指针转换为派生类指针：
        class Base {
        public:
            virtual void foo() {}		//转换的对象必须是多态类型，不然会报错
        };
        class Derived : public Base {
        public:
            void bar() {}
        };
        Base* basePtr = new Derived();  	// 实际指向 Derived 对象
        Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
        if (derivedPtr) {
            derivedPtr->bar();  		// 安全使用
        } else {
            	// 转换失败，basePtr不指向Derived
        }
注意：dymamic_cast转换的对象必须是多态类型(即至少拥有一个虚函数)

当一个派生类指针指向派生类对象，可以使用隐式转化让一个基类指针指向派生类：
        Derived* derivedPtr = new Derived();  // 实际指向 Derived 对象
        Base* basePtr = derivedPtr;




--------------------------------------------------------------------------三、内存管理--------------------------------------------------------------------------
C++存储区域5个：
内存区域	           	存储内容				管理方式			生命周期		特点
栈区 (Stack)	局部变量, 函数参数, 返回地址		编译器自动管理		函数调用/作用域	速度快, 空间有限, 可能栈溢出
堆区 (Heap)	动态分配的内存 (new, malloc)		程序员手动/智能指针管理	从分配到释放	速度慢, 空间大, 可能内存泄漏/碎片
全局/静态存储区	全局变量, 静态变量			编译器分配, OS 回收		整个程序运行期	生命周期长, 分为 Data 和 BSS 段
常量存储区	字符串字面量, 全局常量		编译器分配, OS 回收		整个程序运行期	只读, 共享
代码区 (Code Area)	编译后的可执行机器指令 (例如函数体)	编译器链接器生成, OS 加载	整个程序运行期	只读, 可执行, 可共享
详情可见：https://blog.csdn.net/weixin_40514381/article/details/146522313
注意：只有全局变量、静态变量放在全局/静态区，加上常量前缀后放在常量区。

栈区(局部变量)：接近1MB，可自定义大小。
堆区：大小即虚拟内存的大小，理论上有16G(取决于电脑物理内存，也可能是4G)。

结构体和类都可以选择实例化在堆上或在栈上，他们都可以继承、实现函数、实现多态，作用几乎相同。(C#中结构体是值类型，只能存在栈中，不支持继承，成员默认访问权限是private)
唯二的不同：
class成员的默认访问级别是private，struct成员的默认访问级别是public。
class继承的默认方式是private，struct继承的默认方式是public。









--------------------------------------------------------------------------四、STL标准模板库--------------------------------------------------------------------
C++STL(standard template library)标准模版库：是别人可开发的一系列实用工具的集合，包含容器、算法、迭代器。
STL容器的内容基本都在各个容器头文件(vector、dequeue、list等)的std命名空间中，使用前要加上std::xxx以区分用户自己定义的容器类型，例如std::vector。
STL算法的内容基本都在algorithm头文件的std命名空间中，例如find/sort/copy/reverse等。
容器可以分为顺序式容器和关联式容器，以及C++11引入的无序关联式容器三种
顺序式容器：按照元素插入顺序组织数据，适合需要保持元素顺序或频繁增删末尾元素的场景，底层为数组。
    *vector		动态数组，支持随机访问，末尾插入/删除快
    *deque		双端队列，支持头尾两端的快速插入/删除
    *list		双向链表，任意位置插入/删除快，不支持随机访问
    array		固定大小的数组容器，栈上分配
关联式包括：按照键值对（key-value）或键（key）自动排序，通常是用平衡二叉搜索树（如红黑树）实现的。
    *set		自动排序、不重复的集合
    *map		键值对，按键自动排序
    multiset	允许重复元素的 set
    multimap	允许重复键的 map
无序关联式容器：这是 C++11 引入的新容器，底层基于 哈希表，不保证顺序，但查找速度更快（平均 O(1)）。
    unordered_set		无序、不重复元素集合
    unordered_map		无序键值对容器
    unordered_multiset	无序重复集合
    unordered_multimap	无序重复键值对
至于*stack和*queue，他们是由deque封装而来，不属于以上某一类。

容器：
string：字符串
初始化：
    std::string s;		//空字符串
    std::string s("World")	//构造函数初始化
    std::string s0 = s;              	//拷贝构造函数初始化
    std::string s1 = "Hello";	//从const char*初始化
    std::string s2 = "World";
    std::string s3 = s1 + " " + s2; // 拼接
    s3[0] = 'h';  		// 修改字符
常用方法：
    *s.size()，获取长度
    s.length()，同上，获取长度，推荐用上面的
    *s.find('a')，查找字符或字符串，返回下标，未找到返回std::string::npos
    *s.substr(int pos, int num)，截取字符串
    *< > =等符号，比较阿斯克码值
    *s.insert(pos，str)，在pos下标处插入字符串str 
    *s.erase(int pos, int num)，删除pos下标之后的num个字符，不传num就删完
    *s.replace(pos, num, str)，删除位置pos下标后的num个字符，并插入str
    s.push_back("a")，插入字符a
    s.begin()/end()获取第一个字符/最后一个字符之后的迭代器


vector<>：向量，单端动态数组，内部由一个数组实现
其迭代器是随机访问迭代器
对标C#中的List<>
vector在栈上创建vector对象，内部存有指向堆中数组元素的指针和数组元素的大小。
初始化：
       std::vector<int> v;			//初始化一个空的容器
       vector<int> v1(5);          			// 5个默认初始化元素（0）
       vector<int> v2(5, 100);      			// 5个值为100的元素
       vector<int> v3 = {1, 2, 3};  			// 初始化列表
       vector<Person> vec1 = {Person(1),Person(2)};	// 初始化列表
       vector<int> vec(arr, arr + size);		// 使用数组的指针模拟迭代器来初始化
常用方法：
       v.size()，获取容器元素个数
       v.capacity()，获取容量，为只读
       v.resize(num)，修改容器长度
       v.reserve(int num)，预设容量大小，一般在大致知道要插入的元素数量时，提前设置容量避免多次扩容
       v.empty()，判断容器是否为空
       v.push_back(value)，尾部添加元素
       v.pop_back()，尾部删除元素
       v.begin()，返回指向第一个元素的迭代器，无对应
       v.end()，无对应，返回指向最后一个元素的下一个位置的迭代器1
       v.front()，返回第一个元素
       v.back()，返回最后一个元素
       v.insert(iterator my.begin() + 3, int val)，在下标为3处插入，C++只能用迭代器不能用序号
       v.insert(iterator my.begin() + 3, iterator other.begin(),iterator other.end())
       v.erase(iterator my.begin() + 3)，删除下标为3的元素
       v.erase(iterator  my.begin() + 3, iterator  my.begin() + 4)，删除一段元素(下标3到4的元素)
       v.clear()，清除所有元素
       find(v.begin(),v.end(),int value)，是algorithm库中std作用域的方法，是STL中的算法，寻找某值第一次出现的位置，返回其迭代器，找不到则返回v.end()
       sort(v.begin(), v.end())，是algorithm库中std作用域的方法，是STL中的算法，从小到大排序，有另一个重载类型可以在第三个参数传入函数以指定排序方式
注意：使用迭代器遍历vector来删除某个元素时，小心迭代器失效，要获取返回的迭代器
    // 使用迭代器遍历并删除偶数
    for (auto it = v.begin(); it != v.end();) {
        if (*it % 2 == 0) {
            it = v.erase(it);  // 删除元素并更新迭代器
        } else {
            ++it;  // 如果没有删除，正常前进迭代器
        }
    }
注意：vector创建的数组位于堆上，并且由于实现了深拷贝的拷贝构造函数，所以用vec1来初始化vec2时，改变vec2不会同时改变vec1。

如果vector中存的是自定义类型，则需要重载==运算符以使用find：
bool comparePersons(const Person& a, const Person& b) {
    return a.name == b.name && a.age == b.age;
}
int main(){
      vector<Person> people = { {"Alice", 30}, {"Bob", 25}, {"Charlie", 35} };
      auto it = find(people.begin(), people.end(), Person("Bob", 25));
}
如果想要使用sort有两种方式：
1.在类中重载<运算符
    bool operator<(const Person& other) const {
        return age < other.age; // 根据年龄排序
    }
2.在类外自定义比较函数
bool compareByName(const Person& a, const Person& b) {
    return a.name < b.name; // 根据名字排序
}
用交换技巧来修整vector过剩容量：
vector<int> tmp = v;     //使用拷贝构造函数复制了v，容量等于容器内元素数量
 v.swap(tmp);	     //v和tmp交换数据，容量降下来了

deque<>:双端数组，内部有一个地图(map)和多个内存块组成。地图中存有各内存块地址(即一个地址数组)，每块内存块中包含一段数组，块与块之间不连续，内存块的大小是相同的。
其迭代器是随机访问迭代器
优点：头插、头删效率高于vector
缺点：由于段与段之间不连续，访问效率效率低于vector
push_front(int val)，头插
push_back(int val)，尾插
pop_front()，头删
pop_back()，尾删
其他方法用法和vector容器几乎相同
deque没有capacity和他的设置，因为它和list一样设计的初衷就是可以无限增长(内存不连续)
双端数组可以看做是vector的兄弟，差别不大，在C#中没有对应的类型

stack<>与queue<>：栈与队列，内部由数组实现，不允许用大括号初始化
定义：
std::stack<int> s;
std::queue<int> q;
栈和队列都只有几个接口：
push(int val)，入栈/队列，对应C#栈的Push(int val)和队列的Enqueue(int val)
pop()，出栈/队列，对应C#栈的Pop()和队列的Dequeue()
empty()，判断是否为空
size()，获取大小，对应Count属性
其中栈的特殊接口：
top()，返回栈顶元素，对应Peek()
队列的特殊接口：
front()，返回队列头的元素，对应Peek()
back()，返回队列尾的元素，无对应，但是Linq扩展方法中有Last()方法
两者都没有获取迭代器的接口

list：双向循环链表，由节点构成。节点由数据域和指针域构成，指针域有两个指针，一个是指向前一个节点的指针，另一个是指向后一个节点的指针。
优点：插入删除速度快
缺点：遍历速度慢，占用空间大
list的迭代器是双向迭代器，其迭代器只能前移或者后移(迭代器只支持++和--操作，而不支持+和-，即使+1也不行，也不能直接用[]访问元素
list由于是链表，插入和删除不会造成原有的迭代器失效，而vector会
从C++11开始允许使用大括号初始化list了
赋值：=赋值、assign(iterator begin, iterator end)、assign(int num, int val)
接口：
size()，返回大小
empty()，返回是否为空
resize(int val)，设置大小
push_front()，插入头部
push_back()，插入尾部
pop_front()，删除头部
pop_back()，删除尾部
insert(iterator it, int val)，插入元素
insert(iterator pos, iterator begin, iterator end)，插入一段元素
erase(iterator it)，删除元素
erase(iterator begin, iterator end)，删除一段元素
remove(int val)，删除所有等于val的数据
front()，返回第一个元素
back()，返回最后一个元素
begin()，返回指向第一个元素的迭代器
end()，返回指向最后一个元素后一个位置的迭代器
reverse()，翻转链表，相比algorithm的翻转方法性能更好
clear()，清空容器
l.sort()，排序，因为不支持随机访问迭代器的容器不能用标准快排算法(即不能用sort(li.begin(), li.end()))，所以list自带了一个sort成员方法
l.sort(comparor)，使用特定的排序算法(例如从大到小)，comparor是自己实现的排序方法，返回值是bool，和C#返回值是int不同
find(l.begin(),l.end(),int value)，是STL的方法，寻找某值第一次出现的位置，返回其迭代器，找不到则返回v.end()
对于自定义类型的list，排序一定要指定排序算法
由于无法直接在迭代器上+或-，当需要在下标为50处插入或删除时，可以使用std::advance方法来移动迭代器，它来自iterator头文件(也被vector/list等文件引用，所以一般引入 list就够了)：
int main(){
    std::list<int> myList;
    for (int i = 1; i <= 100; ++i) {
        myList.push_back(i);
    }
    auto it = myList.begin();
    std::advance(it, 50);  // 第51个元素（下标为50）
    myList.insert(it, 999);  
}

set/multiset：集合
set的特点：
    自动排序：元素会在插入时根据大小自动排序（默认用 < 比较）。
    元素唯一：不允许有重复元素(multiset允许)。
    底层实现：作为关联式容器，底层为红黑树。
    迭代器类型：双向迭代器（bidirectional iterator）
set初始化：
    std::set<int> s;			// 最正常的空初始化
    std::set<int> s = {3, 1, 4, 1, 5};  	// 大括号初始化，能够自动去重并排序
    int arr[] = {4, 2, 7, 2, 3};
    std::set<int> s(arr, arr + 5);  		// 使用数组初始化(也可使用vector)
    std::set<int, std::greater<int>> s2; 	// 降序 set，也可自己写greater，要写成仿函数，下面会提及
接口：
    s.insert(int val)：
        对于set：插入可能会失败，所以会返回一个对组pair<set<int>::iterator, bool>，检查pair的second属性可以判断插入是否成功，无论成功与否都会返回容器中指向这个数字的迭代器
        对于multiset：插入必定成功，不用获取返回值
    s.size()
    s.empty()
    s.begin()
    s.end()
    s.erase(iterator it)，移除迭代器指向的元素
    s.erase(iterator begin, iterator end)
    s.erase(int val)，移除特定元素
    s.find(int val)，关联式容器有自己的find方法，元素存在则返回指向该元素的迭代器，不存在就返回end()，可以通过检查是否==s.end()来判断元素是否在set中。
    s.count(int val)，统计元素的个数，在set中只能为0或1，在multiset中有更多，可冒充find方法看返回值是否为0来判断是否存在
通过在模版中传入第二个仿函数参数来实现自定义排序规则。
仿函数(Function Object)是一种通过重载operator()来模拟函数行为的类。在该类实例化后可以当做普通的函数调用，优势作为一个类，相比函数可以保存状态并且具备更强的灵活性。
class Greater {
public:
    bool operator()(int x, int y){
        return x > y;//降序排序
    }
};
int main(){
    set<int, Greater> ss;
}
注意：set和map作为关联式容器，提供了自己的find方法
注意：当模版的参数是自定义类型时，必须传入第二个参数指定排序规则，因为编译器不知道怎么排序。

unordered_set/unordered_multiset：无序集合
unordered_set特点：
    基于哈希表（hash table）实现，使用哈希函数来决定元素的位置。
    元素的顺序是无序的。由于使用哈希表，元素在集合中的顺序取决于它们的哈希值，而不是它们的键值。
    使用哈希表，插入、删除和查找操作的 平均时间复杂度是 O(1)，但最坏情况下（哈希冲突较多）可能退化到 O(n)。
    由于是无序的，所以没有排序操作，也不需要比较函数。
   当不关心元素的顺序，而更关注查找效率时，std::unordered_set会更适合，而set更适合对元素顺序有要求的场景。
unordered_set主要接口：与set相同

map/multimap：有序字典
map特点：
    自动排序：map 会根据键的值进行自动排序，默认情况下按升序排序。
    键唯一性：每个键在 map 中只能出现一次，若用insert插入已存在的键将插入失败，若用operator[]更新已有的键值对可以成功更新。
    元素是键值对：每个元素是一个键值对（pair<const Key, T>），其中 Key 是键类型，T 是值类型。
    基于红黑树：map 是基于红黑树实现的，因此具有对数时间复杂度的插入、删除和查找操作。
map优点：
    高效的查找、插入、删除操作，时间复杂度为O(logn)
map初始化方式：
    std::map<int, std::string> m;					//空初始化
    std::map<int, std::string> m = {{1, "one"}, {2, "two"}, {3, "three"}};	//初始化列表
    std::map<int, std::string> m2 = m1;  				//拷贝构造函数
    std::map<int, std::string> m2(m1.begin(), m1.end());  		//使用另一个map的迭代器
map的主要接口：
    m.size()
    m.empty()
    m.begin()
    m.end()
    m.insert(1, 2);		//插入已存在的键值对不会覆盖原有的值
    m[1] = 2;		//用=赋值改变会更新原有的值
    m.erase(iterator pos)
    m.erase(iterator begin, iterator end)
    m.erase(T key)	//根据key值删除
    m[4] = 40，相当于插入了一个键值对pair<int, int>(4, 40)
    m.find(key)，寻找key是否存在，存在返回指向的迭代器，不存在返回end()
    m.count(key)，查看key的数量，map中为0或1，multimap不是
使用begin和end得到的是指向pair的迭代器，获取key值用it->first，获取值用It->second
使用仿函数可以修改排序的规则，使用方法和set类似。
key的类型是自定义类型时，必须要传入排序规则参数，不然就会报错。

unordered_map/unordered_multimap：无序字典
unordered_map的特点：
    基于哈希表（hash table）实现，键值对的存储顺序是不确定的，元素的排列顺序不依赖于键的顺序。
    插入和删除操作的平均时间复杂度为 O(1)，但在最坏情况下(哈希冲突较多)退化为 O(n)。
    适合不关心元素顺序，而更关心快速查找的场景，而map更适用于需要键有序的场景。
    由于是无序的，所以没有排序操作，也不需要比较函数
unordered_map的接口：和map相同
    m.size()
    m.empty()
    m.begin()
    m.end()
    m.insert(1, 2)，插入已存在的键值对不会覆盖原有的值
    m[1] = 2，用=赋值改变会更新原有的值
    m.erase(iterator pos)
    m.erase(iterator begin, iterator end)
    m.erase(T key)，根据key值删除
    m[4] = 40，相当于插入了一个键值对pair<int, int>(4, 40)
    m.find(key)，寻找key是否存在，存在返回指向的迭代器，不存在返回end()
    m.count(key)，查看key的数量，map中为0或1，multimap不是

优先队列priority_queue：
        1.是队列的一种，包含在queue头文件中。
        2.相比普通的队列queue，priority_queue在使用push放入元素后会对其进行排序，每次pop的都是当前最大(或最小)的元素。
        3.内部使用大根堆(1.完全二叉树，2.每个节点都小于等于父节点)进行排序，插入、删除的时间复杂度为logn。(完全二叉树，除了最底层，每一层节点数都达到最大值，且最底层节点集中于左边，并非搜索树)
        4.一般使用的模版priority_queue<int>创建的是大根堆，pop得到的是最大值，可以看做把元素默认从小到大排列好后，pop输出的是最后的一个值。
        5.当想要用小根堆进行排序时，必须要使用仿函数并指定容器;
                struct MyGreater2 {
                public:
                    bool operator()(int p1, int p2) {
                        return p1 > p2;	//顺序反转
                   }
                };
                 priority_queue<int, vector<int>, MyGreater2> pq	//指定堆的容器为vector<int>
        6.当想要排列其他类型时(例如map)，也要使用模版 priority_queue<pair<int, int>, vector<pair<int, int>>, MyGreater> pq;
        7.用 priority_queue 是为了“只关心最值 + 快速插入弹出”。
使用样例：
    int main() {
        set<int> s = {3, 1, 4, 2};  // 自动排序，不能重复
        priority_queue<int> pq;    // 最大堆
        for (int x : s) pq.push(x);
        for (int x : s) cout << x << " ";  // 输出: 1 2 3 4
        while (!pq.empty()) {
            cout << pq.top() << " ";       // 输出: 4 3 2 1
            pq.pop();
        }
    }

10个容器总结：
    vector：适用于频繁访问元素和追加元素，且插入和删除操作不常发生时。
    deque：适用于需要在两端进行快速插入和删除操作的场景。
    list：适用于频繁插入和删除元素，尤其是在容器中间进行操作时。
    stack：适用于后进先出（LIFO）需求的场景，如函数调用栈。
    queue：适用于先进先出（FIFO）需求的场景，如任务队列。
    set：适用于存储唯一元素并需要自动排序的场景。
    map：适用于存储键值对，并且需要自动排序的场景。
    unordered_set：适用于存储唯一元素并要求快速查找、插入和删除的场景，不关心顺序。
    unordered_map：适用于存储键值对并要求快速查找、插入和删除的场景，不关心顺序。
    priority_queue：只为了“最值 + 快速插入弹出”。可用于解决top-k问题？

注意：
    1.vector和deque容器有迭代器失效风险，注意在插入和删除后更新迭代器为insert、erase的返回值。
    2.set和map中的元素进入时自动排序，故存储自定义类型时必须要在模板的第二个参数指定比较的仿函数或重载比较运算符。
    3.只有vector/deque支持随机访问。
    4.list自己提供了sort方法，set/map自己提供了find方法。
    5.可以使用范围for循环for(int x : vec)来遍历容器(除了stack/queue/priority_queue等)，不然就要使用迭代器了。

--------------------------------------------------------------------------五、高级特性--------------------------------------------------------------------------
decltype关键字：是declaration type(声明类型)的缩写。可以通过括号中表达式的类型返回相应的数据类型。
如果括号中的表达式被第二层括号括起来，则返回一个该类型的引用(引用必须要赋初始值)。
int a = 1;
decltype(i) b = 2;
decltype(i)* aptr = new int(1);
decltype((i)) aref = new int(2);

范围for循环：类似foreach()，只能用于可以求长度的数据结构，例如vector、内置数组等，而用new创建的动态数组无法获取其长度信息，就不能用范围for循环遍历
for(auto i : arr){
    ...
}

C++也有lambda表达式，用来写匿名函数(C#中也是)：
语法如下：
[捕获列表](参数) -> 返回值类型 {
    // 函数体
}
例子：
auto sum = [](int a, int b)-> int {
    return a + b;
};
捕获列表传的是外部的变量，给变量前加&表示捕获引用。若列表中只有一个"="符号，表示按值捕获所有外部变量，若只有一个符号"&"表示按引用捕获所有外部变量。
int x = 42, y = 24;
auto lambda = [x, &y] {
    std::cout << x << ", " << y << std::endl;
};
捕获：用于将外部作用域的变量传递给 lambda 表达式。它控制 lambda 如何与外部变量交互。
参数：用于将数据传递给 lambda 表达式进行计算或处理，类似于普通函数的参数。

析构函数被调用时机：
1.局部类对象离开作用域，调用析构函数。
2.对指向对象的指针使用delete，调用析构函数。
3.类成员对象在所属对象被销毁时，调用析构函数。
4.子类继承自父类，子类销毁时会顺便调用父类析构函数函数。

使用expicit(明确的)修饰的构造函数变为显式构造函数，作用是防止编译器调用构造函数时进行隐式类型转换。
如若需要，详细用法请见上文类与对象。
显式构造函数主要用于确保代码在创建对象时是显式、明确的。这样能清楚地知道每次对象的创建方式，从而减少了可能的错误和不清晰的行为。

智能指针：
智能指针能自动释放堆中内存，防止内存泄漏，有unique_ptr、shared_ptr、weak_ptr三种，来自#include<memory>头文件。智能指针封装的裸指针必须是new出来的对象。
智能指针本身是一个模版类，里面封装了一个指针和一些方法：
重载*和->运算符，让智能指针能和普通指针一样使用。
unique_ptr独占指针中使用xxx() = delete删除系统默认的拷贝构造函数和赋值运算符，为了防止多个智能指针控制同一个指针。
shared_ptr共享指针中不删除拷贝构造和赋值运算符。

unique_ptr是独占指针，独占某个资源的管理权，当该指针被销毁时，对象也会被销毁。由于没有引用计数的内存消耗，unique_ptr的性能比shared_ptr更好。使用unique_ptr后就不要再使用普通指针了。
1.创建方式：
        A* a = new A();
        unique_ptr<A> uptr = unique_ptr<A>(a);
        或
        unique_ptr<A> uptr2 = unique_ptr<A>(new A());	//更为推荐，有这种方式不再需要显示创建普通指针，也防止了一个裸指针被多个独占指针指向的风险
        或
        unique_ptr<int> uptr3 = make_unique<int>(5);
        但是不能
        unique_ptr<A> uptr4 = a;		//不能直接把一个指针赋值给只能指针初始化，智能指针的构造函数用explicit修饰了。
注意：用explicit修饰是为了防止指针作为实参传递给智能指针形参时，使智能指针错误地夺取控制权。
2.成员方法：
        uptr.get()获取裸指针。多用于调用形参是裸指针类型并且只是拿来用而不负责释放指针的方法。
        std::move(uptr)方法转让一个裸指针的控制权，转让后uptr为nullptr，因为直接赋值是不允许的，所以有专门的方法转让裸指针。多用于调用形参是智能指针对象的方法。
                例如：unique_ptr<int> uptr2 = move(uptr);
        uptr.release()方法会释放智能指针，uptr不再管理这个指针并且自身指向nullptr，返回裸指针。释放的是智能指针，并且返回裸指针，多用于转交裸指针控制权。
                例如：unique_ptr<int> uptr2((uptr.release());
        uptr.reset()除了会释放智能指针，指向nullptr，并且会释放原有的裸指针。且该方法可以传入参数，进行只能指针的“重置(reset)”。
                例如：uptr2.reset(new int(20)); 
3.由于是独占指针，不支持多个智能指针指向同一个对象：
        A* a = new A();
        unique_ptr<A> uptr1 = unique_ptr<A>(a);
        unique_ptr<A> uptr2 = unique_ptr<A>(a);		//直接报错
4.由于删除了拷贝构造函数，所以调用函数作为参数不能传值，只能传引用：
        void Func(unique_ptr<A> uptr1) {
        }
        int main() {
	unique_ptr<A> uptr1 = unique_ptr<A>(new A());
	Func(uptr1);		//报错，拷贝构造函数已被删除，想要调用把形参改为unique_ptr<A>& uptr1即可，非要传值要用move(uptr1)替代实参uptr1
        }
5.如果想要在删除对象时做除了delete外的额外操作，可以用仿函数自定义删除器：
        struct MyDeleter {
                void operator()(int* p) const {
                std::cout << "Custom deleter (functor) called, deleting " << *p << std::endl;
                delete p;
            }
        };
        int main() {
            std::unique_ptr<int, MyDeleter> ptr(new int(42));
        }

shared_ptr内部有两个指针成员，一个指向对象，一个指向控制块，控制块中有引用计数、删除器等等。
shared_ptr是共享性指针，可以由多个shared_ptr指向同一个对象。其采用引用计数，当另一个shared_ptr指针指向同一个对象时，控制块的引用计数加一，当某智能指针被销毁或者reset时，引用计数减一，当引用计数为0，该对象被销毁，调用控制块的删除器，删除器调用析构函数。
初始化方法：由于拷贝构造函数和等号运算符没有被删除，可以用一个智能指针初始化另一个智能指针
        shared_ptr<int> sptr = shared_ptr<int>(new int(4));	//普通构造
        shared_ptr<int> sptr2 = shared_ptr<int>(sptr);		//拷贝构造
        shared_ptr<int> sptr3 = sptr;			//拷贝构造
但是注意，一个裸指针只能用来构造一个智能指针，后续智能指针要用已存在的智能指针来构造：
        int* ptr = new int(4);
        shared_ptr<int> sptr = shared_ptr<int>(ptr);	//正确
        shared_ptr<int> sptr2 = shared_ptr<int>(ptr);	//报错，一个裸指针只能用来构造一个共享指针。不用已有的共享指针就无法获取控制块的引用计数并相加了
成员方法：
        sptr.get()方法获取智能指针内部的原始指针。
        没有release方法，因为release返回的裸指针可能会被其他共享指针使用，这是不允许的。
        move()方法转移裸指针控制权。
        用sptr.reset()方法重置智能指针，让智能指针指向nullptr，会让原控制块的引用计数减1。
指定删除器：当储存的对象是动态数组时，要用delete[] ptr;删除，要手动指定删除器
        #include <iostream>
        #include <memory>
        struct DeleteArrayDeleter {
            void operator()(int* ptr) const {
                delete[] ptr;
            }
        };
        int main() {
            int* ptr = new int[5]; 
            std::unique_ptr<int[], DeleteArrayDeleter> uptr(ptr);  
        }
赋值运算符：赋值后会相应改变引用计数
        int main() {
	shared_ptr<int> pa1 = shared_ptr<int>(new int(2));
	shared_ptr<int> pa2 = shared_ptr<int>(pa1);
	shared_ptr<int> pa3 = shared_ptr<int>(pa1);

	shared_ptr<int> pb1 = shared_ptr<int>(new int(3));
	shared_ptr<int> pb2 = shared_ptr<int>(pb1);
	shared_ptr<int> pb3 = shared_ptr<int>(pb1);

	pa2 = pb3;
	cout << pa1.use_count() << endl;		//输出2
	cout << pb1.use_count();			//输出4
        }
线程安全问题：
        shared_ptr本身不是线程安全的。
        shared_ptr的引用计数机制是线程安全的原子操作，但shared_ptr管理的对象本身在多线程环境下操作时可能存在线程安全问题。
循环引用：会阻止shared_ptr智能指针释放内存导致内存泄漏。
        定义：循环引用是指两个智能指针对象内部的智能指针成员互相指向对方，导致它们的引用计数始终不为零，从而无法释放内存。
        例子：
        shared_ptr<A> a = make_shared<A>();
        shared_ptr<B> b = make_shared<B>();
        a->b_ptr = b;
        b->a_ptr = a;
        原因：实际上存在4个智能指针，2个局部变量，2个成员变量。
	  在外部作用域结束时，2个局部变量被释放，但因为两个成员变量互相持有，导致最后引用计数都为1，最终两个裸指针的对象都无法释放。	
        weak_ptr：weak_ptr是一个观察器，没有重载*和->，无法访问指针，不增加对象的引用计数，作用是与shared_ptr一起使用来解决循环依赖。
        weak_ptr只能用shared_ptr来初始化：weak_ptr<int>wp = sptr;
        wptr.use_count()返回对象的引用计数。
        需要使用时，调用wptr.lock()返回指向wptr指向的对象的shared_ptr，std::shared_ptr<A> sptr = wptr.lock();。	
解决循环依赖的方法：把其中一个成员变量shared_ptr换成weak_ptr即可，当然改两个也可以。

进程与线程的区别：
进程是资源分配的基本单位，线程是CPU调度的基本单位。
并发性：进程切换效率低，线程切换效率高。
内存：进程拥有独立的虚拟内存空间，线程只独享有一个很小的栈空间，但是能共享进程的空间。
所属关系：线程依附于进程，不能独立存在。一个进程可以开启多个线程。
健壮性：进程拥有独立的运行环境，拥有更高的健壮性。

左值与右值：能取地址的就是左值，反之是右值。左值可以出现在等号左边或右边，右值只能出现在等号右边。
一、左值：即具名变量，有自己的地址，相当于正式员工
1.x++返回的是一个右值，无法取地址。
2.++x返回的是一个左值，可以取地址和赋值。
3.字符串字面量其实也是一个左值，因为在编译时字符串字面量会被存储到静态区中，就导致它也可以取到地址。&"hello"不会报错。
二、右值：即匿名变量，没有自己的地址，相当于临时工
左值引用：
左值引用即一般的正常引用，只能指向左值，使用&实现，就是在给左值起别名。
例如：
	int a = 1;
	const int b = 2;
	int& ra = a;
	const int& rb = b;
注意：常量左值引用可以指向右值
	const int& rb = 2;
左值引用的意义：
做函数参数时：减少对象赋值，提高性能。
做函数返回值时：减少拷贝，提高效率。引用返回，可修改返回对象
右值引用：
右值引用即对右值的引用，给右值起别名，使用&&实现。
例如：
MyClass Func() {
    return MyClass();
}

int main() {
    int&& a = 2;
    MyClass&& mc = Func();
}
右值引用的意义：
延长右值的生命周期，减少对象复制，提高性能。

--------------------------------------------------------------------------六、编译与链接------------------------------------------------------------------------
C++源代码编译的4个过程：预处理、编译、汇编、链接
预处理：由预编译器负责，删除#define插入宏定义，删除#inlcude插入头文件代码，删除注释。cpp文件经过预编译过程变为.i文件。
编译：由编译器负责，有词法分析、语法分析、语义分析、中间代码生成、目标代码生成等过程。.i文件经过编译过程变为.s文件(汇编文件)。
汇编：由汇编器负责，将.s汇编文件转化为.o/obj文件(机器语言文件，由0/1构成的)。每个cpp文件对应一个.obj文件。
链接：由链接器负责，将所有obj文件和其依赖的库链接起来生成可执行文件。






